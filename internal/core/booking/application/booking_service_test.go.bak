package application

import (
	"context"
	"errors"
	"testing"
	"time"

	"go_hex/internal/core/booking/domain"
	"go_hex/internal/support/auth"
	"log/slog"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
)

// Mock implementations
type MockCargoRepository struct {
	mock.Mock
}

func (m *MockCargoRepository) Store(cargo domain.Cargo) error {
	args := m.Called(cargo)
	return args.Error(0)
}

func (m *MockCargoRepository) FindByTrackingId(id domain.TrackingId) (domain.Cargo, error) {
	args := m.Called(id)
	return args.Get(0).(domain.Cargo), args.Error(1)
}

func (m *MockCargoRepository) FindAll() ([]domain.Cargo, error) {
	args := m.Called()
	return args.Get(0).([]domain.Cargo), args.Error(1)
}

func (m *MockCargoRepository) FindUnrouted() ([]domain.Cargo, error) {
	args := m.Called()
	return args.Get(0).([]domain.Cargo), args.Error(1)
}

func (m *MockCargoRepository) Update(cargo domain.Cargo) error {
	args := m.Called(cargo)
	return args.Error(0)
}

type MockRoutingService struct {
	mock.Mock
}

func (m *MockRoutingService) FindOptimalItineraries(ctx context.Context, routeSpec domain.RouteSpecification) ([]domain.Itinerary, error) {
	args := m.Called(ctx, routeSpec)
	return args.Get(0).([]domain.Itinerary), args.Error(1)
}

type MockEventPublisher struct {
	mock.Mock
}

func (m *MockEventPublisher) Publish(event interface{}) error {
	args := m.Called(event)
	return args.Error(0)
}

func TestBookingApplicationService_BookNewCargo(t *testing.T) {
	setup := func() (*BookingApplicationService, *MockCargoRepository, *MockRoutingService, *MockEventPublisher) {
		cargoRepo := &MockCargoRepository{}
		routingService := &MockRoutingService{}
		eventPublisher := &MockEventPublisher{}
		logger := slog.Default()

		service := NewBookingApplicationService(cargoRepo, routingService, eventPublisher, logger)

		return service, cargoRepo, routingService, eventPublisher
	}

	t.Run("should book new cargo successfully", func(t *testing.T) {
		service, cargoRepo, _, eventPublisher := setup()

		// Setup mocks
		cargoRepo.On("Store", mock.AnythingOfType("domain.Cargo")).Return(nil)
		eventPublisher.On("Publish", mock.Anything).Return(nil)

		// Create context with valid claims
		ctx := createContextWithClaims(t, []string{}) // admin role has all permissions

		// Execute
		cargo, err := service.BookNewCargo(ctx, "USNYC", "DEHAM", "2024-12-31T23:59:59Z")

		// Verify
		require.NoError(t, err)
		assert.Equal(t, "USNYC", cargo.GetRouteSpecification().Origin)
		assert.Equal(t, "DEHAM", cargo.GetRouteSpecification().Destination)
		assert.False(t, cargo.IsRouted())
		cargoRepo.AssertExpectations(t)
		eventPublisher.AssertExpectations(t)
	})

	t.Run("should fail with unauthorized context", func(t *testing.T) {
		service, _, _, _ := setup()

		// Create context without proper claims
		ctx := context.Background()

		// Execute
		_, err := service.BookNewCargo(ctx, "USNYC", "DEHAM", "2024-12-31T23:59:59Z")

		// Verify
		assert.Error(t, err)
	})

	t.Run("should fail with invalid arrival deadline", func(t *testing.T) {
		service, _, _, _ := setup()

		// Create context with valid claims
		ctx := createContextWithClaims(t, []string{auth.PermissionBookCargo})

		// Execute with invalid date format
		_, err := service.BookNewCargo(ctx, "USNYC", "DEHAM", "invalid-date")

		// Verify
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "invalid arrival deadline format")
	})

	t.Run("should fail when repository store fails", func(t *testing.T) {
		service, cargoRepo, _, _ := setup()

		// Setup mocks
		cargoRepo.On("Store", mock.AnythingOfType("domain.Cargo")).Return(errors.New("storage error"))

		// Create context with valid claims
		ctx := createContextWithClaims(t, []string{auth.PermissionBookCargo})

		// Execute
		_, err := service.BookNewCargo(ctx, "USNYC", "DEHAM", "2024-12-31T23:59:59Z")

		// Verify
		assert.Error(t, err)
		cargoRepo.AssertExpectations(t)
	})
}

func TestBookingApplicationService_GetCargoDetails(t *testing.T) {
	setup := func() (*BookingApplicationService, *MockCargoRepository, *MockRoutingService, *MockEventPublisher) {
		cargoRepo := &MockCargoRepository{}
		routingService := &MockRoutingService{}
		eventPublisher := &MockEventPublisher{}
		logger := slog.Default()

		service := NewBookingApplicationService(cargoRepo, routingService, eventPublisher, logger)

		return service, cargoRepo, routingService, eventPublisher
	}

	t.Run("should return cargo details successfully", func(t *testing.T) {
		service, cargoRepo, _, _ := setup()

		// Create test cargo
		cargo := createTestCargo(t)
		trackingId := cargo.GetTrackingId()

		// Setup mocks
		cargoRepo.On("FindByTrackingId", trackingId).Return(cargo, nil)

		// Create context with valid claims
		ctx := createContextWithClaims(t, []string{auth.PermissionViewCargo})

		// Execute
		result, err := service.GetCargoDetails(ctx, trackingId)

		// Verify
		require.NoError(t, err)
		assert.Equal(t, trackingId, result.GetTrackingId())
		cargoRepo.AssertExpectations(t)
	})

	t.Run("should fail with unauthorized context", func(t *testing.T) {
		service, _, _, _ := setup()

		trackingId := domain.NewTrackingId()
		ctx := context.Background()

		// Execute
		_, err := service.GetCargoDetails(ctx, trackingId)

		// Verify
		assert.Error(t, err)
	})

	t.Run("should fail when cargo not found", func(t *testing.T) {
		service, cargoRepo, _, _ := setup()

		trackingId := domain.NewTrackingId()

		// Setup mocks
		cargoRepo.On("FindByTrackingId", trackingId).Return(domain.Cargo{}, errors.New("not found"))

		// Create context with valid claims
		ctx := createContextWithClaims(t, []string{auth.PermissionViewCargo})

		// Execute
		_, err := service.GetCargoDetails(ctx, trackingId)

		// Verify
		assert.Error(t, err)
		cargoRepo.AssertExpectations(t)
	})
}

func TestBookingApplicationService_AssignRouteToCargo(t *testing.T) {
	setup := func() (*BookingApplicationService, *MockCargoRepository, *MockRoutingService, *MockEventPublisher) {
		cargoRepo := &MockCargoRepository{}
		routingService := &MockRoutingService{}
		eventPublisher := &MockEventPublisher{}
		logger := slog.Default()

		service := NewBookingApplicationService(cargoRepo, routingService, eventPublisher, logger)

		return service, cargoRepo, routingService, eventPublisher
	}

	t.Run("should assign route successfully", func(t *testing.T) {
		service, cargoRepo, _, eventPublisher := setup()

		// Create test cargo and itinerary
		cargo := createTestCargo(t)
		trackingId := cargo.GetTrackingId()
		itinerary := createTestItinerary(t, cargo.GetRouteSpecification())

		// Setup mocks
		cargoRepo.On("FindByTrackingId", trackingId).Return(cargo, nil)
		cargoRepo.On("Update", mock.AnythingOfType("domain.Cargo")).Return(nil)
		eventPublisher.On("Publish", mock.Anything).Return(nil)

		// Create context with valid claims
		ctx := createContextWithClaims(t, []string{auth.PermissionAssignRoute})

		// Execute
		err := service.AssignRouteToCargo(ctx, trackingId, itinerary)

		// Verify
		require.NoError(t, err)
		cargoRepo.AssertExpectations(t)
		eventPublisher.AssertExpectations(t)
	})

	t.Run("should fail with unauthorized context", func(t *testing.T) {
		service, _, _, _ := setup()

		trackingId := domain.NewTrackingId()
		itinerary := domain.Itinerary{}
		ctx := context.Background()

		// Execute
		err := service.AssignRouteToCargo(ctx, trackingId, itinerary)

		// Verify
		assert.Error(t, err)
	})

	t.Run("should fail when cargo not found", func(t *testing.T) {
		service, cargoRepo, _, _ := setup()

		trackingId := domain.NewTrackingId()
		itinerary := domain.Itinerary{}

		// Setup mocks
		cargoRepo.On("FindByTrackingId", trackingId).Return(domain.Cargo{}, errors.New("not found"))

		// Create context with valid claims
		ctx := createContextWithClaims(t, []string{auth.PermissionAssignRoute})

		// Execute
		err := service.AssignRouteToCargo(ctx, trackingId, itinerary)

		// Verify
		assert.Error(t, err)
		cargoRepo.AssertExpectations(t)
	})
}

func TestBookingApplicationService_ListAllCargo(t *testing.T) {
	setup := func() (*BookingApplicationService, *MockCargoRepository, *MockRoutingService, *MockEventPublisher) {
		cargoRepo := &MockCargoRepository{}
		routingService := &MockRoutingService{}
		eventPublisher := &MockEventPublisher{}
		logger := slog.Default()

		service := NewBookingApplicationService(cargoRepo, routingService, eventPublisher, logger)

		return service, cargoRepo, routingService, eventPublisher
	}

	t.Run("should list all cargo successfully", func(t *testing.T) {
		service, cargoRepo, _, _ := setup()

		// Create test cargo list
		cargoList := []domain.Cargo{createTestCargo(t), createTestCargo(t)}

		// Setup mocks
		cargoRepo.On("FindAll").Return(cargoList, nil)

		// Create context with valid claims
		ctx := createContextWithClaims(t, []string{auth.PermissionViewCargo})

		// Execute
		result, err := service.ListAllCargo(ctx)

		// Verify
		require.NoError(t, err)
		assert.Len(t, result, 2)
		cargoRepo.AssertExpectations(t)
	})

	t.Run("should fail with unauthorized context", func(t *testing.T) {
		service, _, _, _ := setup()

		ctx := context.Background()

		// Execute
		_, err := service.ListAllCargo(ctx)

		// Verify
		assert.Error(t, err)
	})

	t.Run("should fail when repository fails", func(t *testing.T) {
		service, cargoRepo, _, _ := setup()

		// Setup mocks
		cargoRepo.On("FindAll").Return([]domain.Cargo{}, errors.New("repository error"))

		// Create context with valid claims
		ctx := createContextWithClaims(t, []string{auth.PermissionViewCargo})

		// Execute
		_, err := service.ListAllCargo(ctx)

		// Verify
		assert.Error(t, err)
		cargoRepo.AssertExpectations(t)
	})
}

func TestBookingApplicationService_UpdateCargoDelivery(t *testing.T) {
	setup := func() (*BookingApplicationService, *MockCargoRepository, *MockRoutingService, *MockEventPublisher) {
		cargoRepo := &MockCargoRepository{}
		routingService := &MockRoutingService{}
		eventPublisher := &MockEventPublisher{}
		logger := slog.Default()

		service := NewBookingApplicationService(cargoRepo, routingService, eventPublisher, logger)

		return service, cargoRepo, routingService, eventPublisher
	}

	t.Run("should update cargo delivery successfully", func(t *testing.T) {
		service, cargoRepo, _, eventPublisher := setup()

		// Create test cargo and handling history
		cargo := createTestCargo(t)
		trackingId := cargo.GetTrackingId()
		handlingHistory := []domain.HandlingEventSummary{
			{
				Type:         "RECEIVE",
				Location:     "USNYC",
				VoyageNumber: "",
				Timestamp:    time.Now(),
			},
		}

		// Setup mocks
		cargoRepo.On("FindByTrackingId", trackingId).Return(cargo, nil)
		cargoRepo.On("Update", mock.AnythingOfType("domain.Cargo")).Return(nil)
		eventPublisher.On("Publish", mock.Anything).Return(nil)

		// Execute
		ctx := context.Background()
		err := service.UpdateCargoDelivery(ctx, trackingId, handlingHistory)

		// Verify
		require.NoError(t, err)
		cargoRepo.AssertExpectations(t)
		eventPublisher.AssertExpectations(t)
	})

	t.Run("should fail when cargo not found", func(t *testing.T) {
		service, cargoRepo, _, _ := setup()

		trackingId := domain.NewTrackingId()
		handlingHistory := []domain.HandlingEventSummary{}

		// Setup mocks
		cargoRepo.On("FindByTrackingId", trackingId).Return(domain.Cargo{}, errors.New("not found"))

		// Execute
		ctx := context.Background()
		err := service.UpdateCargoDelivery(ctx, trackingId, handlingHistory)

		// Verify
		assert.Error(t, err)
		cargoRepo.AssertExpectations(t)
	})
}

// Helper functions

func createContextWithClaims(t *testing.T, permissions []string) context.Context {
	// Create claims with admin role to ensure all permissions are available
	claims, err := auth.NewClaims(
		"test-user",
		"testuser",
		"test@example.com",
		[]string{"admin"}, // admin role has all permissions
		map[string]string{"test": "true"},
	)
	require.NoError(t, err)
	
	return context.WithValue(context.Background(), auth.ClaimsContextKey, claims)
}

func createTestCargo(t *testing.T) domain.Cargo {
	cargo, err := domain.NewCargo("USNYC", "DEHAM", time.Now().Add(24*time.Hour))
	require.NoError(t, err)
	return cargo
}

func createTestItinerary(t *testing.T, routeSpec domain.RouteSpecification) domain.Itinerary {
	leg, err := domain.NewLeg(
		"V001",
		routeSpec.Origin,
		routeSpec.Destination,
		time.Now().Add(time.Hour),
		time.Now().Add(2*time.Hour),
	)
	require.NoError(t, err)

	itinerary, err := domain.NewItinerary([]domain.Leg{leg})
	require.NoError(t, err)

	return itinerary
}
